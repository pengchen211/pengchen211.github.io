<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Redis-数据结构 | 彭晨的博客</title>
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="Redis-数据结构" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Reference 《Redis设计与实现》 Redis设计与实现图片集 https://blog.csdn.net/men_wen/article/details/70229375 源码版本:5.0.3" />
<meta property="og:description" content="Reference 《Redis设计与实现》 Redis设计与实现图片集 https://blog.csdn.net/men_wen/article/details/70229375 源码版本:5.0.3" />
<link rel="canonical" href="/redis/2019/03/18/redis-datastructure.html" />
<meta property="og:url" content="/redis/2019/03/18/redis-datastructure.html" />
<meta property="og:site_name" content="彭晨的博客" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-03-18T00:00:00+08:00" />
<script type="application/ld+json">
{"url":"/redis/2019/03/18/redis-datastructure.html","headline":"Redis-数据结构","dateModified":"2019-03-18T00:00:00+08:00","datePublished":"2019-03-18T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/redis/2019/03/18/redis-datastructure.html"},"description":"Reference 《Redis设计与实现》 Redis设计与实现图片集 https://blog.csdn.net/men_wen/article/details/70229375 源码版本:5.0.3","@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="彭晨的博客" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">彭晨的博客</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Redis-数据结构</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2019-03-18T00:00:00+08:00" itemprop="datePublished">Mar 18, 2019
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h4 id="reference">Reference</h4>
<blockquote>
  <ul>
    <li>《Redis设计与实现》</li>
    <li><a href="http://1e-gallery.redisbook.com/index.html">Redis设计与实现图片集</a></li>
    <li><a href="https://blog.csdn.net/men_wen/article/details/70229375">https://blog.csdn.net/men_wen/article/details/70229375</a></li>
    <li>源码版本:5.0.3</li>
  </ul>
</blockquote>

<h3 id="1-简单动态字符串simple-dynamic-string">1 简单动态字符串(simple dynamic string)</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">sdshdr</span> <span class="p">{</span>
   <span class="kt">int</span> <span class="n">len</span><span class="p">;</span> <span class="c1">// 字符串长度</span>
   <span class="kt">int</span> <span class="n">free</span><span class="p">;</span> <span class="c1">// 空闲长度</span>
   <span class="kt">char</span> <span class="n">buf</span><span class="p">[];</span>
<span class="p">};</span>
</code></pre></div></div>
<h4 id="11-图示">1.1 图示</h4>

<p><img src="/assets/redis/redis-sds.png" alt="sds" /></p>

<h4 id="12-优点">1.2 优点</h4>
<ol>
  <li>快速获取字符串长度</li>
  <li>避免缓冲区溢出</li>
  <li>减少修改字符串带来的内存重分配次数
    <blockquote>
      <p><strong>空间分配策略</strong></p>
      <ol>
        <li>空间预分配<br />
 对sds修改并需要扩展长度时，会按一定规则分配额外空间
          <ul>
            <li>长度修改后将小于1MB，则分配与len同样大小的free</li>
            <li>将大于1MB，则分配1MB的free</li>
          </ul>
        </li>
        <li>惰性空间释放<br />
 用于优化sds字符串缩短操作,当字符串缩短时，不会立即回收多于的内存，会将其作为free</li>
      </ol>
    </blockquote>
  </li>
  <li>二进制安全
以二进制方式处理buf里的数据</li>
  <li>兼容C语言字符串函数</li>
</ol>

<h3 id="2-链表">2 链表</h3>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">listNode</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">listNode</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">listNode</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">;</span>
<span class="p">}</span> <span class="n">listNode</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">list</span> <span class="p">{</span>
    <span class="n">listNode</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
    <span class="n">listNode</span> <span class="o">*</span><span class="n">tail</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">dup</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">);</span><span class="c1">// 节点值复制函数</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">free</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">);</span><span class="c1">// 节点值释放函数</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">match</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span><span class="c1">// 节点值对比函数</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span> <span class="n">list</span><span class="p">;</span>
</code></pre></div></div>
<h4 id="21-图示">2.1 图示</h4>
<p><img src="/assets/redis/redis-list.png" alt="link" /></p>

<h3 id="3-字典">3 字典</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 哈希表</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">dictht</span> <span class="p">{</span>
    <span class="c1">// 哈希表数组</span>
    <span class="n">dictEntry</span> <span class="o">**</span><span class="n">table</span><span class="p">;</span><span class="c1">// dictEntry</span>
    <span class="c1">// 哈希表大小</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>
    <span class="c1">// 哈希表大小掩码，用于计算索引值</span>
    <span class="c1">// 总是size - 1，决定一个key映射到table数组哪个索引上</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sizemask</span><span class="p">;</span>
    <span class="c1">// 哈希表已有节点的数量</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">used</span><span class="p">;</span>
<span class="p">}</span> <span class="n">dictht</span><span class="p">;</span>

<span class="c1">// 哈希表节点</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">dictEntry</span> <span class="p">{</span>
    <span class="c1">// 键</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>
    <span class="c1">// 值</span>
    <span class="k">union</span> <span class="p">{</span>
        <span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">;</span>
        <span class="kt">uint64_t</span> <span class="n">u64</span><span class="p">;</span>
        <span class="kt">int64_t</span> <span class="n">s64</span><span class="p">;</span>
        <span class="kt">double</span> <span class="n">d</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">v</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">dictEntry</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span><span class="c1">// 用来解决hash冲突</span>
<span class="p">}</span> <span class="n">dictEntry</span><span class="p">;</span>

<span class="c1">// 字典</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">dict</span> <span class="p">{</span>
    <span class="c1">// 类型特定函数</span>
    <span class="n">dictType</span> <span class="o">*</span><span class="n">type</span><span class="p">;</span>
    <span class="c1">// 私有函数</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">;</span>
    <span class="c1">// 哈希表</span>
    <span class="c1">// 一般只会使用ht[0]，ht[1]在rehash时使用</span>
    <span class="n">dictht</span> <span class="n">ht</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="c1">// rehash索引</span>
    <span class="kt">long</span> <span class="n">rehashidx</span><span class="p">;</span> <span class="cm">/* rehashing not in progress if rehashidx == -1 */</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iterators</span><span class="p">;</span> <span class="cm">/* number of iterators currently running */</span>
<span class="p">}</span> <span class="n">dict</span><span class="p">;</span>

</code></pre></div></div>
<h4 id="31-图示">3.1 图示</h4>
<p><img src="/assets/redis/redis-dictionary.png" alt="dictionary" /></p>

<h4 id="32-rehash">3.2 rehash</h4>
<ol>
  <li>集中式</li>
  <li>渐进式
    <blockquote>
      <ol>
        <li>为ht[1]分配空间，字典同时持有2个hash表</li>
        <li>字典中rehashindex置0</li>
        <li>每次对字典crud，会同时将ht[0]上rehashindex索引上的所有键值对rehash到ht[1],并rehashindex++</li>
        <li>完成后，rehashindex置-1</li>
      </ol>
    </blockquote>
  </li>
</ol>

<h3 id="4-跳跃表skiplist">4 跳跃表(skiplist)</h3>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 节点</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">zskiplistNode</span> <span class="p">{</span>
    <span class="c1">// 数据域</span>
    <span class="n">sds</span> <span class="n">ele</span><span class="p">;</span>
    <span class="c1">// 分值</span>
    <span class="kt">double</span> <span class="n">score</span><span class="p">;</span>
    <span class="c1">// 后退指针</span>
    <span class="k">struct</span> <span class="n">zskiplistNode</span> <span class="o">*</span><span class="n">backward</span><span class="p">;</span>
    <span class="c1">// 层</span>
    <span class="k">struct</span> <span class="n">zskiplistLevel</span> <span class="p">{</span>
       <span class="c1">// 前进指针</span>
        <span class="k">struct</span> <span class="n">zskiplistNode</span> <span class="o">*</span><span class="n">forward</span><span class="p">;</span>
       <span class="c1">// 跨度,当前节点到前进指针指向节点的距离</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">span</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">level</span><span class="p">[];</span>
<span class="p">}</span> <span class="n">zskiplistNode</span><span class="p">;</span>

<span class="c1">// skiplist</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">zskiplist</span> <span class="p">{</span>
    <span class="c1">// 头尾节点</span>
    <span class="k">struct</span> <span class="n">zskiplistNode</span> <span class="o">*</span><span class="n">header</span><span class="p">,</span> <span class="o">*</span><span class="n">tail</span><span class="p">;</span>
    <span class="c1">// 跳表长度</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">length</span><span class="p">;</span>
    <span class="c1">// 所有节点中最大的层数</span>
    <span class="kt">int</span> <span class="n">level</span><span class="p">;</span>
<span class="p">}</span> <span class="n">zskiplist</span><span class="p">;</span>
</code></pre></div></div>
<h4 id="41-图示">4.1 图示</h4>
<p><img src="/assets/redis/redis-skiplist.png" alt="skiplist" /></p>

<h3 id="5-整数集合intset">5 整数集合(intset)</h3>
<p>redis中set类型的底层实现之一,当一个set只包含整数值元素且数量不多时，就会采用intset作为底层实现</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// intset.h</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">intset</span> <span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">encoding</span><span class="p">;</span><span class="c1">//编码方式</span>
    <span class="kt">uint32_t</span> <span class="n">length</span><span class="p">;</span><span class="c1">//元素数量</span>
    <span class="kt">int8_t</span> <span class="n">contents</span><span class="p">[];</span><span class="c1">//保存元素的数组,从小到大,具体元素类型取决于encoding</span>
<span class="p">}</span> <span class="n">intset</span><span class="p">;</span>
</code></pre></div></div>
<h4 id="51-升级upgrade">5.1 升级(upgrade)</h4>
<p>添加新元素时，若新元素比现有元素类型要长，intset需要先进行升级(upgrade),之后才能添加新元素</p>

<p><strong>升级步骤</strong></p>
<blockquote>
  <ol>
    <li>根据新元素类型扩展contents数组大小，并为新元素分配空间</li>
    <li>转换现有元素类型，需保证原有顺序不变</li>
    <li>插入新元素</li>
  </ol>
</blockquote>

<p><strong>升级优点</strong></p>
<blockquote>
  <ul>
    <li>提升灵活性，而不必担心出现类型错误</li>
    <li>节约空间</li>
  </ul>
</blockquote>

<p><strong>注意</strong></p>

<p>intset不支持降级操作，一旦升级就会保持升级后的状态</p>

<h3 id="6-压缩列表ziplist">6 压缩列表(ziplist)</h3>
<blockquote>
  <p>The ziplist is a specially encoded dually linked list that is designed
to be very memory efficient. It stores both strings and integer values,
where integers are encoded as actual integers instead of a series of
characters. It allows push and pop operations on either side of the list
in O(1) time. However, because every operation requires a reallocation of
the memory used by the ziplist, the actual complexity is related to the
amount of memory used by the ziplist.// 来自ziplist.c中的注释</p>
</blockquote>

<h4 id="61-layout">6.1 Layout</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &lt;zlbytes&gt; &lt;zltail&gt; &lt;zllen&gt; &lt;entry&gt; &lt;entry&gt; ... &lt;entry&gt; &lt;zlend&gt;
 
  NOTE: all fields are stored in little endian, if not specified otherwise.
</code></pre></div></div>

<p><strong>说明</strong></p>

<table>
  <thead>
    <tr>
      <th>field</th>
      <th>字节数</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>zlbytes</td>
      <td>4bytes</td>
      <td>ziplist占用的字节数</td>
    </tr>
    <tr>
      <td>zltail</td>
      <td>4bytes</td>
      <td>ziplist尾节点距起始地址多少字节</td>
    </tr>
    <tr>
      <td>zllen</td>
      <td>2bytes</td>
      <td>ziplist包含的节点数量，当节点数量超出其表示范围时节点数量需遍历才能知道</td>
    </tr>
    <tr>
      <td>entry</td>
      <td>不定</td>
      <td>ziplist包含的各个节点，其长度由其内容决定</td>
    </tr>
    <tr>
      <td>zlend</td>
      <td>1byte</td>
      <td>标识ziplist末端，固定值:0xFF(十进制255)</td>
    </tr>
  </tbody>
</table>

<h4 id="62-节点">6.2 节点</h4>
<p>每个ziplist的节点可以保存一个字节数组或者一个整数数值</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> &lt;prevlen&gt; &lt;encoding&gt; &lt;entry-data&gt;
</code></pre></div></div>
<p><strong>prevlen</strong></p>

<p>表示前一个节点长度(byte),自身长度分两种情况：</p>

<ul>
  <li>1字节 前一个节点长度小于254bytes,则只占一字节</li>
  <li>5字节 前一个节点长度不小于254,占5字节.第一字节置254(0xFE)作为标识，余下4字节来表示长度</li>
</ul>

<p><strong>encoding</strong></p>

<p>记录entry-data属性保存的数据类型以及长度,自身长度分两种情况:</p>
<ul>
  <li>1,2或者5字节 值的最高位为00,01或者10.此时entry-data保存着字节数组,长度由encoding除去最高2位后的其他位记录</li>
  <li>1字节 最高位以11开头.此时entry-data保存着整数值</li>
</ul>

<p>字节数组编码</p>

<table>
  <thead>
    <tr>
      <th>encoding</th>
      <th>编码长度</th>
      <th>entry-data属性保存的值</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>00xxxxx</td>
      <td>1byte</td>
      <td>长度&lt;=2^6的字节数组</td>
    </tr>
    <tr>
      <td>01xxxxxx xxxxxxxx</td>
      <td>2bytes</td>
      <td>长度&lt;= 2^14的字节数组</td>
    </tr>
    <tr>
      <td>11xxxxxx . . . .</td>
      <td>5bytes</td>
      <td>长度&lt;= 2^46的字节数组</td>
    </tr>
  </tbody>
</table>

<p>整数编码</p>

<table>
  <thead>
    <tr>
      <th>encoding</th>
      <th>编码长度</th>
      <th>entry-data属性保存的值</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>11000000</td>
      <td>1byte</td>
      <td>int16_t类型的整数</td>
    </tr>
    <tr>
      <td>11010000</td>
      <td>1byte</td>
      <td>int32_t类型的整数</td>
    </tr>
    <tr>
      <td>11100000</td>
      <td>1byte</td>
      <td>int64_t类型的整数</td>
    </tr>
    <tr>
      <td>11110000</td>
      <td>1byte</td>
      <td>24位有符号整数</td>
    </tr>
    <tr>
      <td>11111110</td>
      <td>1byte</td>
      <td>8位有符号整数</td>
    </tr>
    <tr>
      <td>1111xxxx</td>
      <td>1byte</td>
      <td>此时无需entry-data属性，用xxxx来表示0 - 12</td>
    </tr>
  </tbody>
</table>

<p><em>说明</em></p>

<p>1111xxxx时，后4位不能为0000, 1110, 1111.前两个已在其他encoding中使用,最后一个为ziplist的结束标识,故只能0001~1101，又因数值从0开始故又在其基础上减1</p>

<p><strong>entry-data</strong></p>

<p>保存节点的值，字节数组或者整数，由encoding决定</p>

<h4 id="63-连锁更新">6.3 连锁更新</h4>
<p>当一系列略小于254bytes的节点前出现一个大于254bytes的节点后，使得后续节点连续扩展prevlen为5bytes</p>
<blockquote>
  <ol>
    <li>插入大节点</li>
    <li>删除节点与大节点之间的节点，使得小节点前出现了大节</li>
  </ol>
</blockquote>

<p><em>图示</em></p>

<p><img src="/assets/redis/redis-ziplist-chain-update.png" alt="chain-extend" /></p>

<h3 id="7-快速列表quicklist">7 快速列表(quicklist)</h3>
<p>多个quicklistNode结构组成一个双向链表，每个节点指向一个ziplist
quicklist结构再持有双向链表的头、尾</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// quicklist.h</span>

<span class="c1">// quicklist is a 40 byte struct (on 64-bit systems) describing a quicklist.</span>
<span class="c1">// 'count' is the number of total entries.</span>
<span class="c1">// 'len' is the number of quicklist nodes.</span>
<span class="c1">// 'compress' is: -1 if compression disabled, otherwise it's the number</span>
<span class="c1">// of quicklistNodes to leave uncompressed at ends of quicklist.</span>
<span class="c1">//  'fill' is the user-requested (or default) fill factor.</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">quicklist</span> <span class="p">{</span>
    <span class="n">quicklistNode</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
    <span class="n">quicklistNode</span> <span class="o">*</span><span class="n">tail</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">;</span>        <span class="cm">/* total count of all entries in all ziplists */</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">;</span>          <span class="cm">/* number of quicklistNodes */</span>
    <span class="c1">// 对应list-max-ziplist-size配置项</span>
    <span class="c1">// specify the number of entries for per list node</span>
    <span class="c1">// 负数(-1~-5)标识fixed maximun size</span>
    <span class="c1">// 整数表示ziplist中entry的个数</span>
    <span class="kt">int</span> <span class="n">fill</span> <span class="o">:</span> <span class="mi">16</span><span class="p">;</span>              <span class="cm">/* fill factor for individual nodes */</span>
    <span class="c1">// 对应list-compress-depth配置项</span>
    <span class="c1">// 压缩深度，0表示不压缩，1表示两端各一个节点不压缩</span>
    <span class="c1">// 依此类推</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">compress</span> <span class="o">:</span> <span class="mi">16</span><span class="p">;</span> <span class="cm">/* depth of end nodes not to compress;0=off */</span>
<span class="p">}</span> <span class="n">quicklist</span><span class="p">;</span>

<span class="c1">// quicklistNode is a 32 byte struct describing a ziplist for a quicklist.</span>
<span class="c1">// We use bit fields keep the quicklistNode at 32 bytes.</span>
<span class="c1">// count: 16 bits, max 65536 (max zl bytes is 65k, so max count actually &lt; 32k).</span>
<span class="c1">// encoding: 2 bits, RAW=1, LZF=2.</span>
<span class="c1">// container: 2 bits, NONE=1, ZIPLIST=2.</span>
<span class="c1">// recompress: 1 bit, bool, true if node is temporarry decompressed for usage.</span>
<span class="c1">// attempted_compress: 1 bit, boolean, used for verifying during testing.</span>
<span class="c1">//  extra: 10 bits, free for future use; pads out the remainder of 32 bits   </span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">quicklistNode</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">quicklistNode</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">quicklistNode</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">zl</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sz</span><span class="p">;</span>             <span class="cm">/* ziplist size in bytes */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">:</span> <span class="mi">16</span><span class="p">;</span>     <span class="cm">/* count of items in ziplist */</span>
    <span class="c1">// 压缩编码</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">encoding</span> <span class="o">:</span> <span class="mi">2</span><span class="p">;</span>   <span class="cm">/* RAW==1 or LZF==2 */</span>
    <span class="c1">// 是否采用ziplist结构保存数据</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">container</span> <span class="o">:</span> <span class="mi">2</span><span class="p">;</span>  <span class="cm">/* NONE==1 or ZIPLIST==2 */</span>
    <span class="c1">// 标记节点是否被压缩过</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">recompress</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* was this node previous compressed? */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">attempted_compress</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* node can't compress; too small */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">extra</span> <span class="o">:</span> <span class="mi">10</span><span class="p">;</span> <span class="cm">/* more bits to steal for future usage */</span>
<span class="p">}</span> <span class="n">quicklistNode</span><span class="p">;</span>

<span class="c1">// quicklistLZF is a 4+N byte struct holding 'sz' followed by 'compressed'.</span>
<span class="c1">// 'sz' is byte length of 'compressed' field.</span>
<span class="c1">// 'compressed' is LZF data with total (compressed) length 'sz'</span>
<span class="c1">// NOTE: uncompressed length is stored in quicklistNode-&gt;sz.</span>
<span class="c1">// When quicklistNode-&gt;zl is compressed, node-&gt;zl points to a quicklistLZF </span>
<span class="c1">// 压缩过的ziplist结构,采用lzf压缩算法</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">quicklistLZF</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sz</span><span class="p">;</span> <span class="cm">/* LZF size in bytes*/</span>
    <span class="kt">char</span> <span class="n">compressed</span><span class="p">[];</span>
<span class="p">}</span> <span class="n">quicklistLZF</span><span class="p">;</span>
</code></pre></div></div>

  </div><a class="u-url" href="/redis/2019/03/18/redis-datastructure.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">彭晨的博客</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">彭晨的博客</li><li><a class="u-email" href="mailto:pengchen211@163.com">pengchen211@163.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p></p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
